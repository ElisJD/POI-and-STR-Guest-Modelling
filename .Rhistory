df <- as.data.frame(edinburgh_airbnb_tourism_fs)
# Create coords matrix
coords_mat <- df[, c("X", "Y")]
# Clean and ensure all required data
vars <- c("total_revenue_log", features_logged, "X", "Y")
df_clean <- df[complete.cases(df[, vars]), vars]
df_clean$glx_id <- edinburgh_airbnb_tourism_fs$glx_id[
!is.na(edinburgh_airbnb_tourism_fs$total_revenue_log) &
!is.nan(edinburgh_airbnb_tourism_fs$total_revenue_log) &
is.finite(edinburgh_airbnb_tourism_fs$total_revenue_log)
]
gwr_formula <- as.formula(paste("total_revenue_log ~", paste(features_logged, collapse = " + ")))
# Ensure coords are numeric matrix, not list/data.frame
coords_mat <- as.matrix(df_clean[, c("X", "Y")])
storage.mode(coords_mat) <- "double"  # ensures correct numeric type
bw_opt <- gwr.sel(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = TRUE
)
gwr_model <- gwr(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = bw_opt,
hatmatrix = TRUE,
se.fit = TRUE
)
gwr_model
local_r2_df <- data.frame(
glx_id = df_clean$glx_id,
gwr_revenue_local_r2 = gwr_model$SDF$localR2
)
edinburgh_airbnb_tourism_fs <- edinburgh_airbnb_tourism_fs %>%
left_join(local_r2_df, by = "glx_id")
# Clean and ensure all required data
vars <- c("total_volume_log", features_logged, "X", "Y")
df_clean <- df[complete.cases(df[, vars]), vars]
df_clean$glx_id <- edinburgh_airbnb_tourism_fs$glx_id[
!is.na(edinburgh_airbnb_tourism_fs$total_volume_log) &
!is.nan(edinburgh_airbnb_tourism_fs$total_volume_log) &
is.finite(edinburgh_airbnb_tourism_fs$total_volume_log)
]
gwr_formula <- as.formula(paste("total_volume_log ~", paste(features_logged, collapse = " + ")))
# Ensure coords are numeric matrix, not list/data.frame
coords_mat <- as.matrix(df_clean[, c("X", "Y")])
storage.mode(coords_mat) <- "double"  # ensures correct numeric type
bw_opt <- gwr.sel(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = TRUE
)
gwr_model <- gwr(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = bw_opt,
hatmatrix = TRUE,
se.fit = TRUE
)
gwr_model
local_r2_df <- data.frame(
glx_id = df_clean$glx_id,
gwr_volume_local_r2 = gwr_model$SDF$localR2
)
edinburgh_airbnb_tourism_fs <- edinburgh_airbnb_tourism_fs %>%
left_join(local_r2_df, by = "glx_id")
# Clean and ensure all required data
vars <- c("total_tourism_intensity_km2_log", features_logged, "X", "Y")
df_clean <- df[complete.cases(df[, vars]), vars]
df_clean$glx_id <- edinburgh_airbnb_tourism_fs$glx_id[
!is.na(edinburgh_airbnb_tourism_fs$total_tourism_intensity_km2_log) &
!is.nan(edinburgh_airbnb_tourism_fs$total_tourism_intensity_km2_log) &
is.finite(edinburgh_airbnb_tourism_fs$total_tourism_intensity_km2_log)
]
gwr_formula <- as.formula(paste("total_tourism_intensity_km2_log ~", paste(features_logged, collapse = " + ")))
# Ensure coords are numeric matrix, not list/data.frame
coords_mat <- as.matrix(df_clean[, c("X", "Y")])
storage.mode(coords_mat) <- "double"  # ensures correct numeric type
bw_opt <- gwr.sel(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = TRUE
)
gwr_model <- gwr(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = bw_opt,
hatmatrix = TRUE,
se.fit = TRUE
)
gwr_model
local_r2_df <- data.frame(
glx_id = df_clean$glx_id,
gwr_density_local_r2 = gwr_model$SDF$localR2
)
edinburgh_airbnb_tourism_fs <- edinburgh_airbnb_tourism_fs %>%
left_join(local_r2_df, by = "glx_id")
features_logged <- c(
'air_travel_density_log',
'arts_other_density_log',
'bars_nightlife_density_log',
'cafes_bakeries_density_log',
'cultural_institution_density_log',
'dining_other_density_log',
'entertainment_nightlife_density_log',
'event_space_density_log',
'fast_food_density_log',
'food_drink_production_density_log',
'full_service_restaurant_density_log',
'high_end_dining_density_log',
'historic_landmark_density_log',
'leisure_activity_centre_density_log',
'local_public_transit_density_log',
'lodging_density_log',
'major_attraction_density_log',
'major_transit_hub_density_log',
'mobility_services_density_log',
'music_cinema_venue_density_log',
'nature_trail_density_log',
'outdoors_other_density_log',
'park_garden_density_log',
'public_art_density_log',
'public_plaza_square_density_log',
'retail_books_hobbies_density_log',
'retail_fashion_apparel_density_log',
'retail_food_beverage_density_log',
'retail_gifts_misc_density_log',
'retail_health_beauty_density_log',
'retail_home_electronics_density_log',
'retail_luxury_density_log',
'retail_markets_plazas_density_log',
'retail_other_density_log',
'rural_agricultural_density_log',
'tourism_services_density_log',
'transport_infrastructure_density_log',
'travel_other_density_log',
'waterfront_river_density_log'
)
# Keep only rows with valid total_revenue_log
df_clean <- df[complete.cases(df[, c("total_revenue_log", features_logged, "X", "Y")]), ]
# Create coords
coords_clean <- df_clean[, c("X", "Y")]
grf_formula <- as.formula(paste("total_revenue_log ~", paste(features_logged, collapse = " + ")))
grf_model <- grf(
formula = grf_formula,
dframe = df_clean,
bw = 48,
kernel = "adaptive",
coords = coords_clean,
ntree = 500,
importance = "impurity",
geo.weighted = TRUE,
forests = TRUE,
nthreads = 4
)
# 1. Extract local importance matrix
local_importance_matrix <- grf_model$Local.Variable.Importance  # a matrix [n_polygons x n_features]
# 2. Assign column names for clarity
colnames(local_importance_matrix) <- features_logged
# 3. Get most important feature for each row (polygon)
most_important_feature <- apply(local_importance_matrix, 1, function(x) {
features_logged[which.max(x)]
})
# 4. Create a dataframe to join with glx_id
feature_df <- data.frame(
glx_id = df_clean$glx_id,
gwrf_revenue_top_feature = most_important_feature
)
# 5. Join back to your main GeoDataFrame
edinburgh_airbnb_tourism_fs <- edinburgh_airbnb_tourism_fs %>%
left_join(feature_df, by = "glx_id")
# Keep only rows with valid total_revenue_log
df_clean <- df[complete.cases(df[, c("total_volume_log", features_logged, "X", "Y")]), ]
# Create coords
coords_clean <- df_clean[, c("X", "Y")]
grf_formula <- as.formula(paste("total_volume_log ~", paste(features_logged, collapse = " + ")))
grf_model <- grf(
formula = grf_formula,
dframe = df_clean,
bw = 48,
kernel = "adaptive",
coords = coords_clean,
ntree = 500,
importance = "impurity",
geo.weighted = TRUE,
forests = TRUE,
nthreads = 4
)
# 1. Extract local importance matrix
local_importance_matrix <- grf_model$Local.Variable.Importance  # a matrix [n_polygons x n_features]
# 2. Assign column names for clarity
colnames(local_importance_matrix) <- features_logged
# 3. Get most important feature for each row (polygon)
most_important_feature <- apply(local_importance_matrix, 1, function(x) {
features_logged[which.max(x)]
})
# 4. Create a dataframe to join with glx_id
feature_df <- data.frame(
glx_id = df_clean$glx_id,
gwrf_volume_top_feature = most_important_feature
)
# 5. Join back to your main GeoDataFrame
edinburgh_airbnb_tourism_fs <- edinburgh_airbnb_tourism_fs %>%
left_join(feature_df, by = "glx_id")
# Keep only rows with valid total_revenue_log
df_clean <- df[complete.cases(df[, c("total_tourism_intensity_km2_log", features_logged, "X", "Y")]), ]
# Create coords
coords_clean <- df_clean[, c("X", "Y")]
grf_formula <- as.formula(paste("total_tourism_intensity_km2_log ~", paste(features_logged, collapse = " + ")))
grf_model <- grf(
formula = grf_formula,
dframe = df_clean,
bw = 48,
kernel = "adaptive",
coords = coords_clean,
ntree = 500,
importance = "impurity",
geo.weighted = TRUE,
forests = TRUE,
nthreads = 4
)
# 1. Extract local importance matrix
local_importance_matrix <- grf_model$Local.Variable.Importance  # a matrix [n_polygons x n_features]
# 2. Assign column names for clarity
colnames(local_importance_matrix) <- features_logged
# 3. Get most important feature for each row (polygon)
most_important_feature <- apply(local_importance_matrix, 1, function(x) {
features_logged[which.max(x)]
})
# 4. Create a dataframe to join with glx_id
feature_df <- data.frame(
glx_id = df_clean$glx_id,
gwrf_density_top_feature = most_important_feature
)
# 5. Join back to your main GeoDataFrame
edinburgh_airbnb_tourism_fs <- edinburgh_airbnb_tourism_fs %>%
left_join(feature_df, by = "glx_id")
# Save to GeoPackage
st_write(edinburgh_airbnb_tourism_fs, "../../data/edinburgh/edinburgh_airbnb_tourism_fs.gpkg", delete_dsn = TRUE)
head(london_airbnb_tourism_fs$gwrf_density_top_feature
head(london_airbnb_tourism_fs$gwrf_density_top_feature)
library(sf)
library(spgwr)
library(SpatialML)
library(dplyr)
london_airbnb_tourism_fs <- st_read('../../data/london/london_airbnb_tourism_fs.gpkg')
features_logged <- c(
"cultural_institution_density_log",
"cafes_bakeries_density_log",
"bars_nightlife_density_log",
"local_public_transit_density_log"
)
# Calculate centroids if geometries are polygons
gdf_centroids <- st_centroid(london_airbnb_tourism_fs)
# Extract coordinates
coords <- st_coordinates(gdf_centroids)
# Add to data frame
london_airbnb_tourism_fs$X <- coords[, 1]
london_airbnb_tourism_fs$Y <- coords[, 2]
# Convert to plain data.frame
df <- as.data.frame(london_airbnb_tourism_fs)
# Create coords matrix
coords_mat <- df[, c("X", "Y")]
# Clean and ensure all required data
vars <- c("total_revenue_log", features_logged, "X", "Y")
df_clean <- df[complete.cases(df[, vars]), vars]
df_clean$glx_id <- london_airbnb_tourism_fs$glx_id[
!is.na(london_airbnb_tourism_fs$total_revenue_log) &
!is.nan(london_airbnb_tourism_fs$total_revenue_log) &
is.finite(london_airbnb_tourism_fs$total_revenue_log)
]
gwr_formula <- as.formula(paste("total_revenue_log ~", paste(features_logged, collapse = " + ")))
# Ensure coords are numeric matrix, not list/data.frame
coords_mat <- as.matrix(df_clean[, c("X", "Y")])
storage.mode(coords_mat) <- "double"  # ensures correct numeric type
bw_opt <- gwr.sel(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = TRUE
)
gwr_model <- gwr(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = bw_opt,
hatmatrix = TRUE,
se.fit = TRUE
)
gwr_model
local_r2_df <- data.frame(
glx_id = df_clean$glx_id,
gwr_revenue_local_r2 = gwr_model$SDF$localR2
)
london_airbnb_tourism_fs <- london_airbnb_tourism_fs %>%
left_join(local_r2_df, by = "glx_id")
# Clean and ensure all required data
vars <- c("total_volume_log", features_logged, "X", "Y")
df_clean <- df[complete.cases(df[, vars]), vars]
df_clean$glx_id <- london_airbnb_tourism_fs$glx_id[
!is.na(london_airbnb_tourism_fs$total_volume_log) &
!is.nan(london_airbnb_tourism_fs$total_volume_log) &
is.finite(london_airbnb_tourism_fs$total_volume_log)
]
gwr_formula <- as.formula(paste("total_volume_log ~", paste(features_logged, collapse = " + ")))
# Ensure coords are numeric matrix, not list/data.frame
coords_mat <- as.matrix(df_clean[, c("X", "Y")])
storage.mode(coords_mat) <- "double"  # ensures correct numeric type
bw_opt <- gwr.sel(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = TRUE
)
gwr_model <- gwr(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = bw_opt,
hatmatrix = TRUE,
se.fit = TRUE
)
gwr_model
local_r2_df <- data.frame(
glx_id = df_clean$glx_id,
gwr_volume_local_r2 = gwr_model$SDF$localR2
)
london_airbnb_tourism_fs <- london_airbnb_tourism_fs %>%
left_join(local_r2_df, by = "glx_id")
# Clean and ensure all required data
vars <- c("total_tourism_intensity_km2_log", features_logged, "X", "Y")
df_clean <- df[complete.cases(df[, vars]), vars]
df_clean$glx_id <- london_airbnb_tourism_fs$glx_id[
!is.na(london_airbnb_tourism_fs$total_tourism_intensity_km2_log) &
!is.nan(london_airbnb_tourism_fs$total_tourism_intensity_km2_log) &
is.finite(london_airbnb_tourism_fs$total_tourism_intensity_km2_log)
]
gwr_formula <- as.formula(paste("total_tourism_intensity_km2_log ~", paste(features_logged, collapse = " + ")))
# Ensure coords are numeric matrix, not list/data.frame
coords_mat <- as.matrix(df_clean[, c("X", "Y")])
storage.mode(coords_mat) <- "double"  # ensures correct numeric type
bw_opt <- gwr.sel(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = TRUE
)
gwr_model <- gwr(
formula = gwr_formula,
data = df_clean,
coords = coords_mat,
adapt = bw_opt,
hatmatrix = TRUE,
se.fit = TRUE
)
gwr_model
local_r2_df <- data.frame(
glx_id = df_clean$glx_id,
gwr_density_local_r2 = gwr_model$SDF$localR2
)
london_airbnb_tourism_fs <- london_airbnb_tourism_fs %>%
left_join(local_r2_df, by = "glx_id")
features_logged <- c(
'air_travel_density_log',
'arts_other_density_log',
'bars_nightlife_density_log',
'cafes_bakeries_density_log',
'cultural_institution_density_log',
'dining_other_density_log',
'entertainment_nightlife_density_log',
'event_space_density_log',
'fast_food_density_log',
'food_drink_production_density_log',
'full_service_restaurant_density_log',
'high_end_dining_density_log',
'historic_landmark_density_log',
'leisure_activity_centre_density_log',
'local_public_transit_density_log',
'lodging_density_log',
'major_attraction_density_log',
'major_transit_hub_density_log',
'mobility_services_density_log',
'music_cinema_venue_density_log',
'nature_trail_density_log',
'outdoors_other_density_log',
'park_garden_density_log',
'public_art_density_log',
'public_plaza_square_density_log',
'retail_books_hobbies_density_log',
'retail_fashion_apparel_density_log',
'retail_food_beverage_density_log',
'retail_gifts_misc_density_log',
'retail_health_beauty_density_log',
'retail_home_electronics_density_log',
'retail_luxury_density_log',
'retail_markets_plazas_density_log',
'retail_other_density_log',
'rural_agricultural_density_log',
'tourism_services_density_log',
'transport_infrastructure_density_log',
'travel_other_density_log',
'waterfront_river_density_log'
)
# Keep only rows with valid total_revenue_log
df_clean <- df[complete.cases(df[, c("total_revenue_log", features_logged, "X", "Y")]), ]
# Create coords
coords_clean <- df_clean[, c("X", "Y")]
grf_formula <- as.formula(paste("total_revenue_log ~", paste(features_logged, collapse = " + ")))
grf_model <- grf(
formula = grf_formula,
dframe = df_clean,
bw = 48,
kernel = "adaptive",
coords = coords_clean,
ntree = 500,
importance = "impurity",
geo.weighted = TRUE,
forests = TRUE,
nthreads = 4
)
# 1. Extract local importance matrix
local_importance_matrix <- grf_model$Local.Variable.Importance  # a matrix [n_polygons x n_features]
# 2. Assign column names for clarity
colnames(local_importance_matrix) <- features_logged
# 3. Get most important feature for each row (polygon)
most_important_feature <- apply(local_importance_matrix, 1, function(x) {
features_logged[which.max(x)]
})
# 4. Create a dataframe to join with glx_id
feature_df <- data.frame(
glx_id = df_clean$glx_id,
gwrf_revenue_top_feature = most_important_feature
)
# 5. Join back to your main GeoDataFrame
london_airbnb_tourism_fs <- london_airbnb_tourism_fs %>%
left_join(feature_df, by = "glx_id")
# Keep only rows with valid total_revenue_log
df_clean <- df[complete.cases(df[, c("total_volume_log", features_logged, "X", "Y")]), ]
# Create coords
coords_clean <- df_clean[, c("X", "Y")]
grf_formula <- as.formula(paste("total_volume_log ~", paste(features_logged, collapse = " + ")))
grf_model <- grf(
formula = grf_formula,
dframe = df_clean,
bw = 48,
kernel = "adaptive",
coords = coords_clean,
ntree = 500,
importance = "impurity",
geo.weighted = TRUE,
forests = TRUE,
nthreads = 4
)
# 1. Extract local importance matrix
local_importance_matrix <- grf_model$Local.Variable.Importance  # a matrix [n_polygons x n_features]
# 2. Assign column names for clarity
colnames(local_importance_matrix) <- features_logged
# 3. Get most important feature for each row (polygon)
most_important_feature <- apply(local_importance_matrix, 1, function(x) {
features_logged[which.max(x)]
})
# 4. Create a dataframe to join with glx_id
feature_df <- data.frame(
glx_id = df_clean$glx_id,
gwrf_volume_top_feature = most_important_feature
)
# 5. Join back to your main GeoDataFrame
london_airbnb_tourism_fs <- london_airbnb_tourism_fs %>%
left_join(feature_df, by = "glx_id")
# Keep only rows with valid total_revenue_log
df_clean <- df[complete.cases(df[, c("total_tourism_intensity_km2_log", features_logged, "X", "Y")]), ]
# Create coords
coords_clean <- df_clean[, c("X", "Y")]
grf_formula <- as.formula(paste("total_tourism_intensity_km2_log ~", paste(features_logged, collapse = " + ")))
grf_model <- grf(
formula = grf_formula,
dframe = df_clean,
bw = 48,
kernel = "adaptive",
coords = coords_clean,
ntree = 500,
importance = "impurity",
geo.weighted = TRUE,
forests = TRUE,
nthreads = 4
)
# 1. Extract local importance matrix
local_importance_matrix <- grf_model$Local.Variable.Importance  # a matrix [n_polygons x n_features]
# 2. Assign column names for clarity
colnames(local_importance_matrix) <- features_logged
# 3. Get most important feature for each row (polygon)
most_important_feature <- apply(local_importance_matrix, 1, function(x) {
features_logged[which.max(x)]
})
# 4. Create a dataframe to join with glx_id
feature_df <- data.frame(
glx_id = df_clean$glx_id,
gwrf_density_top_feature = most_important_feature
)
# 5. Join back to your main GeoDataFrame
london_airbnb_tourism_fs <- london_airbnb_tourism_fs %>%
left_join(feature_df, by = "glx_id")
# Save to GeoPackage
st_write(london_airbnb_tourism_fs, "../../data/london/london_airbnb_tourism_fs.gpkg", delete_dsn = TRUE)
head(london_airbnb_tourism_fs$gwrf_density_top_feature
head(london_airbnb_tourism_fs$gwrf_density_top_feature)
tail(london_airbnb_tourism_fs$gwrf_density_top_feature)
